Abstract
Developing large-scale parallel programs that are free of errors, that execute efficiently and that scale well up to very large numbers of processors, is a very challenging task, even more if timing requirements are added. As current programming models (MPI and OpenMP) provide a rather low level of abstraction, parallel programs are susceptible to synchronization errors such as deadlocks, race conditions, unintended non-determinism, communication errors (e.g., a send that has no matching receive), and performance problems such as uneven distribution of load or high synchronization/communication overhead. Here, we present a new approach that allows quantitative analysis of timing behavior for parallel interactions. In our approach the two computer science areas 'HPC' and 'Software Engineering' interact. Hybrid automata are used as special models for parallel programs to describe time conditions from both areas very comfortably. As consequence results of our software verification are combined with lower-level performance prediction of HPC as well as support higher-level decision processes of software engineering.
1. Introduction
In HPC, parallel programming is necessary for solution of complex scientific problems in efficient time [17]. Software development of parallel programs is often difficult and error-prone. Complexity in communication of single programs and program executions under real-time conditions in distributed, heterogeneous environments (GRIDs) make the development process more complicated. In applications with high economic costs as well as time- and safety-critical properties automatic methods for proving of correctness in parallel programs are needed to detect and avoid errors.
Most current tools focus on validation, i.e., they can detect the presence of errors but are not able to verify the parallel program, i.e. prove the absence of errors. Tools that focus on verification, like MPI SPIN [20], consider the temporal ordering of events relative to each other but do not have a quantitative view of time.
Our approach allows quantitative analysis of timing behavior. It combines verication of parallel interactions with performance prediction on specific hardware platforms and supports decisions of users and engineers in software development processes. We can prove systems of timing conditions that are separated during the modeling phase but that interact with each other. Separation of timing conditions in different sets makes complex models much easier to read and to maintain. For instance, we distinguish high-level software and low-level hardware conditions. The requirements of users and software developers to the behavior of the program are software conditions. For instance, a CFD code may require guaranteed ordering of events in a determined time. If new velocity values are calculated then the values must be received before termination of calculation of new pressure values within three seconds for example.
Software conditions include correctness requirements, e.g., freedom of deadlock, absence of race conditions within determined time periods. The performance characteristics of the hardware platform are hardware conditions. Hardware conditions are obtained by running benchmarks on the platform of interest. Both sets of conditions are combined in hybrid automata [7].
Hybrid automata combine discrete and continuous components. In parallel programs the begin and end of statements and functions are discrete components. Time periods needed for execution of statements and functions are the continuous components. Compared to real-time statecharts [19] hybrid automata can unite two complete independent condition systems without a mixture of software and hardware conditions. The different kinds of conditions are directly assigned with special components of the hybrid automaton, software conditions with continuous locations and hardware conditions with discrete transitions. So an additional transformation step for mixture of conditions at one and the same component is avoided. The readability and maintainability of the models are improved. Thus, software requirements and hardware preconditions can be described independently of each other but can then be proved and brought into agreement automatically.
The method is currently being implemented for MPI programs. For a given requirement, the tool will either confirm that this requirement will be met, or it will identify a section of source code that may cause program execution to fail to meet the requirement. Our approach is based on symbolic simulation of hybrid automata. A synchronized hybrid automaton is derived from the hybrid automata that describe the hardware and software conditions. The language accepted by that automaton is a set of timed words that describe possible program executions that meet the specified time condition. This process is referred to as symbolic simulation [18]. The behavior of the parallel program thus is represented as a formal language. This allows us to use results from formal language theory in the process of verification.
Symbolic simulation is an automatic verification method as model checking [3] that proves properties of timed systems. It is a process of accepting symbolic timed words. A symbolic timed word is a sequence of events together with their symbolic time of occurrence. Events symbolize the begin and the end of an statement or function in a parallel program. Symbolic time represents a period of time. In an MPI program, the events are represented by labels. Labels, statements, and functions are associated with real-time conditions.
Questions as follows can be answered on the foundation of our verification results:
- How complex may process communication be?
- Is it possible to meet time conditions for finishing a complete calculation process?
- Do critical situations appear in a network where hardware components must be exchanged/eliminated or tasks must be divided in another order?
- How can high-level software time conditions for a parallel program be changed to agree with performance parameters of the hardware?
Here development phases of error-free software as planning, analysis and validation/verification are addressed. Correct propositions for properties of parallel programs have a special influence on requirement and functional specifications as well as refactoring and reengineering processes [4]. For the first time, symbolic simulation of hybrid automata is applied in the area of software development of parallel programs, especially MPI programs, to calculate and interpret correct predictions for high-level decision processes in the software development.
After focusing the topic in the introduction, in section 2 our approach is motivated in the area of related work. An MPI example for illustration is introduced in section 3. The little example leads to a fundamental understanding of our simulation approach by avoiding trajectory explosions as it can be the case for real-world applications. To reduce number of trajectories special reduction and abstraction mechanisms have to be applied like in [3]. How parallel programs are transformed into models for symbolic simulation, hybrid automata, can be found in section 4. Section 5 includes a simpliÔ¨Åed example for symbolic simulation and conclusions of the application of verification results for 'HPC' and 'Software engineering'. A summary and conclusions inform about our finished works and recently running works in section 6.
2 Related Work
The area of parallel programming is characterized by two directions of software development. Implicit parallel programs are developed by parallelization of sequential statement sequences and explicit programs by direct descriptions from software developers. Some works deal with automatic parallelization of sequential programs [9, 14] because manual parallelization is very time-consuming. In that way, correctness proofs of sequential programs and compilers for parallelization are sufficient. But here the known problem exists that proofs for properties in a sequential original program can be executed easier than derive a parallel target program with the same properties [10]. The library functions of many standards like MPI are implemented on a low abstraction level and difficult to use. Thus a parallelization of sequential programs is very complex. As consequence parallel programs are often developed by software engineers explicitly according to their knowledge and experiences. The question for correctness of explicit parallel programs arises for time- and safety-critical applications.
Hand-written parallel programs are tested by a range of approaches [8, 13] and proved of correctness in [15]. Particularly parallel programs on the basis of MPI are explored in accordance to critical sections and race conditions [5, 21].
Our method distinguishes from other methods by additional consideration of real-time properties and the proof of the properties. Our symbolic simulation of hybrid automata is based on language theory and uses expertise like language inclusion, reachability and decidability. Further, results are interpreted under different application-views for a higherlevel software development process.

